/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.queixal.ssl;

import static org.junit.jupiter.api.Assertions.assertNotEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertThrows;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.UnsupportedEncodingException;
import java.net.URL;
import java.security.cert.X509Certificate;

import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLHandshakeException;
import javax.net.ssl.SSLSession;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestInstance;
import org.junit.jupiter.api.TestInstance.Lifecycle;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@TestInstance(Lifecycle.PER_METHOD)
class SSLPlaygroundTest {

    private static final Logger log = LoggerFactory.getLogger(SSLPlaygroundTest.class);
    private String httpsURL = "https://localhost/";

    /**
     * Send an https request without removing java default truststore and hostname
     * validator, this will thro a SSLHandshakeException because a self signed
     * certificate must be inside the java cacerts before calling it
     */
    @Test
    void testHTTPSWithCertCheck() throws Exception {
        URL url = new URL(httpsURL);
        var con = (HttpsURLConnection) url.openConnection();
        con.setRequestMethod("GET");
        // read response
        assertThrows(SSLHandshakeException.class, () -> con.getInputStream());
        con.disconnect();
    }

    /**
     * Send an HTTPS request but removing java default truststore and hostname validation
     * @throws Exception
     */
    @Test
    void testHTTPSWithoutCertCheck() throws Exception {

        SSLContext sc = SSLContext.getInstance("TLS");
        sc.init(null, new TrustManager[] { new TrustAllX509TrustManager() }, new java.security.SecureRandom());
        var defaultSSLVerifier = HttpsURLConnection.getDefaultSSLSocketFactory();
        var defaultHostnameVerifier = HttpsURLConnection.getDefaultHostnameVerifier();

        HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());
        HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier() {
            public boolean verify(String string, SSLSession ssls) {
                return true;
            }
        });

        var httpsURL = "https://localhost/";
        URL url = new URL(httpsURL);
        HttpsURLConnection con = (HttpsURLConnection) url.openConnection();
        con.setRequestMethod("GET");

        // read response
        try (var in = new BufferedReader(new InputStreamReader(con.getInputStream()))) {
            String inputLine;
            StringBuffer content = new StringBuffer();
            while ((inputLine = in.readLine()) != null) {
                content.append(inputLine);
            }
            assertNotNull(content.toString());
            assertNotEquals("", content.toString());
            HttpsURLConnection.setDefaultSSLSocketFactory(defaultSSLVerifier);
            HttpsURLConnection.setDefaultHostnameVerifier(defaultHostnameVerifier);
        } finally {
            con.disconnect();
        }
    }

    public class TrustAllX509TrustManager implements X509TrustManager {
        public X509Certificate[] getAcceptedIssuers() {
            return new X509Certificate[0];
        }

        public void checkClientTrusted(java.security.cert.X509Certificate[] certs, String authType) {
        }

        public void checkServerTrusted(java.security.cert.X509Certificate[] certs, String authType) {
        }

    }
}
