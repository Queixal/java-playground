/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.queixal.ssl;

import static org.junit.jupiter.api.Assertions.assertNotEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.net.URI;
import java.net.URL;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpRequest.BodyPublishers;
import java.net.http.HttpResponse.BodyHandler;
import java.net.http.HttpResponse.BodySubscriber;
import java.net.http.HttpResponse.BodySubscribers;
import java.net.http.HttpResponse.ResponseInfo;
import java.nio.charset.Charset;
import java.security.cert.X509Certificate;

import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLHandshakeException;
import javax.net.ssl.SSLSession;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestInstance;
import org.junit.jupiter.api.TestInstance.Lifecycle;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@TestInstance(Lifecycle.PER_METHOD)
class SSLPlaygroundTest {

    private static final Logger log = LoggerFactory.getLogger(SSLPlaygroundTest.class);
    private String httpsURL = "https://localhost/";

    /**
     * Send an https request without removing java default truststore and hostname
     * validator, this will thro a SSLHandshakeException because a self signed
     * certificate must be inside the java cacerts before calling it
     */
    @Test
    void testHTTPSWithCertCheck() throws Exception {
        URL url = new URL(httpsURL);
        var con = (HttpsURLConnection) url.openConnection();
        con.setRequestMethod("GET");
        // read response
        assertThrows(SSLHandshakeException.class, () -> con.getInputStream());
        con.disconnect();
    }

    @Test
    void testUsingJkd11HTTPClient() throws Exception {
        var defaultSSLVerifier = HttpsURLConnection.getDefaultSSLSocketFactory();
        var defaultHostnameVerifier = HttpsURLConnection.getDefaultHostnameVerifier();

        var props = System.getProperties();
        props.setProperty("jdk.internal.httpclient.disableHostnameVerification", "true");
        HttpsURLConnection.setDefaultHostnameVerifier((hostname, session) -> true);

        SSLContext sslContext = SSLContext.getInstance("TLS");
        sslContext.init(null, new TrustManager[] { new X509TrustManager() {
            public X509Certificate[] getAcceptedIssuers() {
                return null;
            }

            public void checkClientTrusted(java.security.cert.X509Certificate[] certs, String authType) {
            }

            public void checkServerTrusted(java.security.cert.X509Certificate[] certs, String authType) {
            }
        } }, new java.security.SecureRandom());

        // Install the all-trusting host verifier
        HttpsURLConnection.setDefaultSSLSocketFactory(sslContext.getSocketFactory());

        // // Set SSL parameters
        HttpClient httpClient = HttpClient.newBuilder().sslContext(sslContext)
        //.sslParameters(parameters)
        .build();
        var request = HttpRequest.newBuilder().uri(URI.create(httpsURL))
        .POST(BodyPublishers.ofString("")).build();


        httpClient.send(request, new BodyHandler<String>() {
            @Override
            public BodySubscriber<String> apply(ResponseInfo responseInfo) {
                BodySubscriber<String> upstream = BodySubscribers.ofString(Charset.defaultCharset());
                return BodySubscribers.mapping(upstream, (string) -> string);
            }
        });

        assertTrue(true);
        HttpsURLConnection.setDefaultSSLSocketFactory(defaultSSLVerifier);
        HttpsURLConnection.setDefaultHostnameVerifier(defaultHostnameVerifier);
        props.setProperty("jdk.internal.httpclient.disableHostnameVerification", "false");
    }

    /**
     * Send an HTTPS request but removing java default truststore and hostname
     * validation
     * 
     * @throws Exception
     */
    @Test
    void testHTTPSWithoutCertCheck() throws Exception {

        SSLContext sc = SSLContext.getInstance("TLS");
        sc.init(null, new TrustManager[] { new TrustAllX509TrustManager() }, new java.security.SecureRandom());
        var defaultSSLVerifier = HttpsURLConnection.getDefaultSSLSocketFactory();
        var defaultHostnameVerifier = HttpsURLConnection.getDefaultHostnameVerifier();

        HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());
        HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier() {
            public boolean verify(String string, SSLSession ssls) {
                return true;
            }
        });

        var httpsURL = "https://localhost:443/";
        URL url = new URL(httpsURL);
        HttpsURLConnection con = (HttpsURLConnection) url.openConnection();
        con.setRequestMethod("POST");

        // read response
        try (var in = new BufferedReader(new InputStreamReader(con.getInputStream()))) {
            String inputLine;
            StringBuffer content = new StringBuffer();
            while ((inputLine = in.readLine()) != null) {
                content.append(inputLine);
            }
            assertNotNull(content.toString());
            assertNotEquals("", content.toString());
            HttpsURLConnection.setDefaultSSLSocketFactory(defaultSSLVerifier);
            HttpsURLConnection.setDefaultHostnameVerifier(defaultHostnameVerifier);
        } finally {
            con.disconnect();
        }
    }

    public class TrustAllX509TrustManager implements X509TrustManager {
        public X509Certificate[] getAcceptedIssuers() {
            return new X509Certificate[0];
        }

        public void checkClientTrusted(java.security.cert.X509Certificate[] certs, String authType) {
        }

        public void checkServerTrusted(java.security.cert.X509Certificate[] certs, String authType) {
        }

    }
}
